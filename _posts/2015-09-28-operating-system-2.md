---
layout: post
title: 操作系统2——进程与线程
categories: 操作系统 笔记
date: 2015-09-28 16:19:22
---

这也是操作系统处理机管理的部分。

<!-- more -->

### 进程的定义描述

* 进程的概念：进程是操作系统中最核心的概念，操作系统其他所有内容都是围绕进程概念展开的；
    * 程序的顺序执行和并发执行
    * 进程的定义和描述
    * 进程的状态

程序的顺序执行和并发执行：顺序执行有着顺序性、封闭性和可再现性的美好的性质，可惜没有效率；并发执行间断、失去了封闭性和可再现性（外界环境影响），但是它效率高啊！而且顺序执行显然不物理，没有人是顺序执行的。。。

并发执行的程序，会共享系统资源，用程序是不能方便描述的，于是就引入了进程的概念，用于描述程序执行时动态特征。通常，OS核心不是一个进程。

进程的特征包括：动态性、独立性、并发、异步、交互、结构化等等。

* 进程与程序的区别：
    * 进程是动态的，程序是静态的
    * 进程是暂时的，程序是长久的
    * 进程与程序的组成不同：进程包括程序、数据和进程控制块
    * 对应关系：一个程序可对应多个进程（多次执行）；一个进程可包括多个程序（调用）



* 进程控制块（PCB）：操作系统管理和控制进程的一个专门数据结构，记录进程的外部特征，描述进程的运动变化过程；PCB是系统感知进程存在的唯一标识，同时PCB与进程也是一一对应的。
    * 内容包括进程描述信息、进程控制信息、资源占用信息、CPU现场保护信息
        * 进程描述信息：PID，进程名、用户标识符、进程组
        * 进程控制信息：当前状态、优先级、代码执行入口地址、程序外存地址、运行统计信息（执行时间、页面调度）、进程间同步和通信、阻塞原因
        * 资源占用信息：虚拟地址空间的现状和打开文件列表
        * CPU现场保护信息：寄存器值（通用、PC、PSW、地址包括栈指针），指向赋予该进程的段/页表的指针
    * PCB表的组织方式：系统把所有PCB组织在一起放在内存固定区域，就构成了PCB表，或者进程表；大小决定了最多可同时存在的进程个数
        * 链接结构：统一状态PCB构成一链表，例如阻塞链表、就绪链表
        * 索引结构：同意状态进程归入一个index表，例如就绪索引表、阻塞索引表
* 进程映象：用户程序、数据、堆栈、PCB
* 进程上下文：对进程执行活动全过程的静态描述。由进程的用户地址空间内容，硬件寄存器内容以及相关的核心数据结构组成
    * 用户级上下文：进程的用户地址空间，包括用户正文段、数据段和用户栈
    * 寄存器级上下文：程序寄存器、处理机状态寄存器、栈指针、通用寄存器的值
    * 系统及上下文：静态部分（PCB和资源表格）、动态部分（核心栈）
* OS和进程的关系
    * UNIX：OS作为进程地址空间的一部分
    * Windows NT：OS功能分别在核心和系统服务进程中，只有OS核心作为进程地址空间的一部分。

### 实例：Linux进程控制块
在Linux内核中，所有进程用一个双向循环链表联系起来形成一个**进程链表**，链表的前后指针为PCB中的`struct list_head tasks`中的`prev`和`next`成员，表头为`init_task`进程控制块。


## 线程模型
每个进程内部有一个或多个线程。

* **多线程** 特指一个进程内部可以有多个线程
* 线程共享进程的地址空间和资源
* 多个线程可以共同完成一个任务。
* 多线程——每个线程有自己的头(TCB)，每个线程有其自己的(用户和内核)栈(自己的局部变量、函数、传递参数)

### 进程与线程的比较
* 地址空间和其他资源：进程间相互独立，线程共享部分资源
* 通信：线程相互通信无须调用内核(IPC)
* 调度：线程调度(创建、结束、同进程间切换)开销小
* 缺点：在程序设计模型中引入复杂性

### 线程应用实例
* 字处理程序
    * 输入——分析——字/命令(存盘/...)/...——输入。如果单线程存盘则会阻塞，然后`***.exe未响应`，多线程则不会发生这种问题。
* 多线程Web服务器
    * 用户请求——在内存取出——若不在内存则从硬盘读取到内存——返回...。同样是硬盘读取阻塞

## 线程实现机制

### 用户级线程(ULT)
* 由应用程序完成所有线程管理，与操作系统无关
* 线程切换不需要核心态特权，并且是应用特定的
* POSIX的pthread多线程编程接口
* 线程在一个运行时系统上运行
    * 线程库(运行时系统)：创建撤销线程、线程之间传递消息和数据、调度线程执行、保护和回复线程上下文
* 每个进程有专用线程表
* 内核活动：操作系统内核不知道线程，依然管理进程；线程调用系统调用时，整个进程阻塞；对线程库来说，线程仍然是运行状态，即线程状态和进程状态是独立的。
* 优点
    * 切换不需要内核，性能良好
    * 调度是应用程序特定的，可针对应用优化
    * 任何操作系统上运行
* 缺点
    * 调度非抢先、简单
    * 系统调用阻塞所有线程
    * 内核只将处理器分给进程

### 内核级线程
* 由内核管理，没有线程库但有API
* 内核维护线程，以线程为单位调度
* 不需要线程库线程表，内核有总线程表
* 优点
    * 多处理器，内核可以同时调度多个线程
    * 阻塞是在线程一级完成的
    * 内核例程是多线程的
* 缺点：同一进程内的线程切换调用内核，导致性能下降

### 混合实现
使用内核级线程，将用户级线程与某些或者全部内核级线程复用起来

## Windows线程
Windows支持内核级线程，进程什么都不执行，只有4GB的地址空间用来存放应用程序需要的代码数据DLL等。

* 进程是惰性的，必须至少有一个线程来负责执行包含在地址空间中的代码
* 多线程，都在地址空间中并发
* 每个线程有自己的CPU寄存器组和栈
* 第一个线程自动创建

### 线程状态
* 就绪状态：已获得除处理机以外的资源，等待执行。选择执行->备用态
* 备用状态：已选择好处理器，等待上下文切换。每个处理器只有一个备用态线程。
    * 抢先->就绪
    * 上下文切换->运行
* 运行状态：直到内核抢先、线程终止、时间片用完或进入等待
    * 等待对象句柄->等待状态
    * 抢先或执行结束->就绪态
    * 执行完成->终止
* 等待状态：等待某事件发生，结束后根据优先级进入运行、就绪态
    * 等待完成->就绪或运行
    * 换出的内核堆栈->过渡
* 过渡状态：准备执行且内核堆栈处于外存
    * 内核堆栈调入内存->就绪
* 终止：重新初始化->初始化
* 初始化：线程创建过程中的线程状态
    * 放入就绪队列->就绪

### API
* `CreateThread()`：创建线程
* `ExitThread()`：退出线程
* `SuspendThread()`：挂起指定线程
* `ResumeThread()`：挂起倒计时

```c
#include <windows.h>
#include <stdio.h>

#define MAX_THREAD 3

typedef struct _MyData{
    int val1;
    int val2;
}MYDATA, *PMYDATA;

DWORD WINAPI ThreadProc(LPVOID lpParam){
    PMYDATA pData;
    pData = (PMYDATA)lpParam;
    printf("This is Thread %d, the Parameter is %d\n", pData->val1, pData->2);

    HeapFree(GetProcessHeap(), 0, pData);

    return 0;
}

void main(){
    PMYDATA pData;
    DWORD dwThreadId[MAX_THREAD];
    HANDLE hThread[MAX_THREAD];
    int i;

    for(i=0; i<MAX_THREAD; i++ ){
        pData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MYDATA));

        if(pData==NULL)
            ExitProcess(2);

        pData->val1 = i;
        pData->val2 = i+100;
        hThread[i] = CreateThread(
            NULL,
            0,
            ThreadProc,
            pData,
            0,
            &dwThreadId[i]);
        if(hThread[i]==NULL)
            ExitProcess(i);
    }
    
    WaitForMultipleObjects(MAX_THREAD, hThread, TRUE, INFINITE);

    for(i = 0;i<MAX_THREAD;i++)
        CloseHandle(hThread[i]);
}

```

## POSIX线程
pthread线程库调用

开头

```c++
#define _REENTRANT
#include <pthread.h>
```

并编译时使用`-lpthread`选项连接

## Linux线程
实现线程机制非常独特。从内核角度，只有进程没有线程，线程仅仅被视为共享资源的进程

实现线程使用一个新的系统调用`sys_clone()`